#!/usr/bin/env perl

use 5.020;
use warnings;

use Getopt::Long qw(:config no_ignore_case bundling); # see perldoc
use File::Basename;
use File::chdir;

use constant { TMPDIR      => defined $ENV{TMPDIR}? $ENV{TMPDIR} : "/tmp"
             , BAKADIR     => "/baka"
             , BAKA_SUFFIX => ".baka" };

sub help {
     say "We will get there.";

     exit(0);
}

# change function name
sub extract_tmp {
     my $source = $_[0];

     unless (-e $source) {
          say "Could'nt find sorce file. Aborting.";
          exit(1);
     }

     chomp(my $valid_baka = `tar -tf $source 2>/dev/null | wc -l`);

     if (! $valid_baka) { # check if source is a valid tar.gz archive, and if
                          # there are any content in it
          say "File '$valid_baka' is not a valid baka file. Aborting.";
          exit(1);
     }

     unless (-e "${\TMPDIR}${\BAKADIR}") { # baka dir doesn't exist
          `mkdir ${\TMPDIR}${\BAKADIR}`;
     }

     `tar -xpzf $source -C ${\TMPDIR}${\BAKADIR}`;
}

# recieves a path string, and returns a list indexed by the files full name
# of their stat (date and time)
sub file_stat {
     my $path = $_[0];

     my %stat; # 0 => date, 1 => time

     for my $file (split /\n/, `/bin/zsh -c \'ls -pdRA $path/**/* |\\
                               grep -P "[^:/]\$"\'`) {

          my ($min, $hour, $day, $mon, $year) = (localtime(
               (stat($file))[9]
          ))[1 .. 5]; # time and date derived from the files mtime

          $year += 1900; # "fix" the date format, see perldoc localtime
          $mon  += 1;    # it may not be necessary, but for now it stays

          $stat{$file} = ["$year-$mon-$day", "$hour:$min"];
     }

     return %stat;
}

# recieves target path, and head of the tmp path
# returns a list of the newer files in the tmp path
sub get_newer_files {
     my ($tmp, $target) = @_;

     # for each file in tmp get its date and time
     # compare with the correspondent file in target
     # return a list of the newer files in tmp
     #
     # ls
     # awk returns filename with suffix, date, time
     # filter directories
     # same for target
     # compare lists
     # save only the newer files from tmp
     #

     my %tmp_stat = &file_stat($tmp);
     # my %fs_stat  = &file_stat($target);

     for my $file (keys %tmp_stat) { # debug
          say "$tmp_stat{$file}[0] $tmp_stat{$file}[1] $file";
     }

     return 0;
}

# recieve two paths (files) and check if they exist in the fs
# return the correspondent error message, or false otherwise
sub there_are_files {
     my ($source, $target) = @_;

     unless (-e $source) {
          return "Couldn't find source. Aborting.";
     }

     unless (-d $target) {
          return "Couldn't find target. Aborting.";
     }

     return ""; # empty string will be seen as a boolean false value
}

# creates a new backup (target) file for source dir
sub new_baka_file {
     my ($basename, $path, $suffix) = fileparse($_[0], BAKA_SUFFIX);
     my $target = $_[1];

     if (my $err = &there_are_files("$path$basename$suffix", $target)) {
          say $err;
          exit(1);
     }

     if (-e "$target/$basename${\BAKA_SUFFIX}") {
          print "Baka, file already exists. Overwrite it? [y/N]: ";
          chomp(my $ans = <STDIN>);

          given ($ans) {
               when (/^$|[Nn]/) { say "Leaving."; exit(0)     }
               when (/[Yy]/)    { say "Overwriting..."; break }

               default {
                    say "Unexpected answer. Aborting.";
                    exit(1);
               }
          }
     }

     local $CWD = $path; # changing current work dir to the source path

     `tar -cpzf $target/$basename${\BAKA_SUFFIX} $basename$suffix`;
}

sub update_baka_file {
     my ($basename, $path, $suffix) = fileparse($_[0], BAKA_SUFFIX);
     my $target = $_[1];

     if (my $err = &there_are_files("$path$basename$suffix", $target)) {
          say $err;
          exit(1);
     }
}

sub baka_baka_file {
     my ($basename, $path, $suffix) = fileparse($_[0], BAKA_SUFFIX);
     my $target = $_[1];

     if (my $err = &there_are_files("$path$basename$suffix", $target)) {
          say $err;
          exit(1);
     }
}

sub main {
     my %options;

     # info about the meaning of the arguments can be found at sub help
     GetOptions( \%options
               , 'help'
               , 'n', 'b', 'u'
               , 's=s', 't=s'
     ) or do {
          say "BAKA! You're using it wrong. See --help for instructions.";
          exit(1);
     };

     # &get_newer_files();

     &help if (defined $options{'help'});

     if (defined $options{n}) {
          &new_baka_file($options{'s'}, $options{'t'});
     }

     if (defined $options{b}) {
          &extract_tmp($options{'s'}, $options{'t'});
     }

     if (defined $options{u}) {
          &get_newer_files("${\TMPDIR}${\BAKADIR}");
     }
}

&main if (__FILE__ eq $0);

=begin cmnt
     ## will be used later

     say $date[3];
     say $date[4] + 1;
     say $date[5] + 1900;
     ##
=end cmnt
